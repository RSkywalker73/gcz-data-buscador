# Configuración de Supabase — bd_valorizaciones (Producción)

> **Proyecto:** GCZ Data Buscador — Producción
> **Base de datos:** PostgreSQL (Supabase) — mismo proyecto
> **Schema:** `cgoii-data-prod`
> **Tabla:** `bd_valorizaciones`
> **Última actualización:** Febrero 2026

⚠️ **Esta tabla se crea dentro del schema `cgoii-data-prod` existente, junto a `PQT06_Facturas_Consulta_Master`.**
Todos los objetos (funciones, triggers, índices) llevan sufijo `_val` para evitar colisiones.

---

## Estado de implementación

| Paso | Descripción | Estado |
|------|-------------|--------|
| 1 | Verificar schema `cgoii-data-prod` | ⬜ Pendiente |
| 2 | Verificar extensiones | ⬜ Pendiente |
| 3 | Crear tabla `bd_valorizaciones` | ⬜ Pendiente |
| 4 | Crear índices de búsqueda | ⬜ Pendiente |
| 5 | Crear trigger de búsqueda | ⬜ Pendiente |
| 6 | Crear función RPC de búsqueda | ⬜ Pendiente |
| 7 | Configurar permisos (Grants) | ⬜ Pendiente |
| 8 | Frontend apuntando a nueva tabla | ⬜ Pendiente |

---

## Guía paso a paso (replicable)

### Paso 1 — Verificar schema

El schema ya existe. Este paso es solo confirmación.

```sql
-- Idempotente — si ya existe no hace nada
create schema if not exists "cgoii-data-prod";
```

---

### Paso 2 — Verificar extensiones

Ya activadas para la tabla de facturas. Confirmación:

```sql
create extension if not exists unaccent schema public;
create extension if not exists pg_trgm schema public;
```

---

### Paso 3 — Crear tabla principal

```sql
create table "cgoii-data-prod"."bd_valorizaciones" (
  -- Identificador (auto-generado, no existe en Excel)
  id_registro bigint generated by default as identity not null,

  -- Campos de clasificación
  item text null,
  cod_int text null,
  tipo text null,
  ie text null,
  val text null,
  mes timestamp without time zone null,
  fecha timestamp without time zone null,

  -- Centro de costos y servicio
  centro_costos text null,
  grupo_servicio text null,
  concepto text null,

  -- Orden de servicio y documento
  os text null,
  documento_factura text null,
  ruc text null,
  proveedor text null,
  nombre_descripcion text null,

  -- Montos y aprobación
  presentado numeric null,
  aprobado text null,
  observacion_desestimado text null,
  concepto_2 text null,
  monto_aprobado_arcc numeric null,

  -- Destino aprobación 1
  dest_aprob_1 text null,
  fecha_2 text null,
  val_apb_1 text null,

  -- Destino aprobación 2
  dest_aprob_2 text null,
  fecha_mes_2 text null,
  val_apb_2 text null,

  -- Destino aprobación 3
  dest_aprob_3 text null,
  fecha_mes_3 text null,
  val_apb_3 text null,

  -- Destino aprobación 4
  dest_aprob_4 text null,
  fecha_mes_4 text null,
  val_apb_4 text null,

  -- Saldos y totales
  saldo_por_aprobar numeric null,
  total_aprobado numeric null,

  -- Comentarios y paginación
  comentarios text null,
  nro_pag text null,

  -- Columnas auxiliares (del Excel)
  columna_2 text null,
  columna_3 text null,
  columna_4 text null,

  -- Columna de búsqueda full-text
  busqueda_vector tsvector null,

  -- Primary key
  constraint bd_valorizaciones_prod_pkey primary key (id_registro)
) tablespace pg_default;
```

> **Total: 40 columnas + PK auto-generado.**
> Los campos `Columna2`, `Columna3`, `Columna4` del Excel se mantienen como reserva. Si no se necesitan, se pueden omitir.

---

### Paso 4 — Crear índices de búsqueda

#### 4a. Índice GIN para búsqueda full-text

```sql
create index if not exists idx_busqueda_valorizaciones_prod
on "cgoii-data-prod"."bd_valorizaciones" using gin (busqueda_vector)
tablespace pg_default;
```

#### 4b. Función auxiliar `immutable_unaccent`

> Ya existe en `public` (creada para la tabla de facturas). No es necesario recrearla. Si es una instalación nueva, ejecutar:

```sql
create or replace function public.immutable_unaccent(text)
returns text as $$
  select public.unaccent($1);
$$ language sql immutable parallel safe;
```

#### 4c. Función auxiliar `immutable_timestamp_to_text`

> PostgreSQL no permite crear índices sobre expresiones con `::text` cast de un `timestamp` porque no es `IMMUTABLE`. Necesitamos este wrapper para el índice fuzzy sobre `mes`.

```sql
create or replace function public.immutable_timestamp_to_text(timestamp without time zone)
returns text as $$
  select $1::text;
$$ language sql immutable parallel safe;
```

#### 4d. Índices fuzzy (trigramas) para columnas con ILIKE

```sql
create index if not exists idx_fuzzy_search_proveedor_val
on "cgoii-data-prod"."bd_valorizaciones" using gin (
  immutable_unaccent(lower(proveedor)) gin_trgm_ops
) tablespace pg_default;

create index if not exists idx_fuzzy_search_ruc_val
on "cgoii-data-prod"."bd_valorizaciones" using gin (
  immutable_unaccent(lower(ruc)) gin_trgm_ops
) tablespace pg_default;

create index if not exists idx_fuzzy_search_os_val
on "cgoii-data-prod"."bd_valorizaciones" using gin (
  immutable_unaccent(lower(os)) gin_trgm_ops
) tablespace pg_default;

create index if not exists idx_fuzzy_search_documento_factura_val
on "cgoii-data-prod"."bd_valorizaciones" using gin (
  immutable_unaccent(lower(documento_factura)) gin_trgm_ops
) tablespace pg_default;

create index if not exists idx_fuzzy_search_nombre_descripcion_val
on "cgoii-data-prod"."bd_valorizaciones" using gin (
  immutable_unaccent(lower(nombre_descripcion)) gin_trgm_ops
) tablespace pg_default;

create index if not exists idx_fuzzy_search_ie_val
on "cgoii-data-prod"."bd_valorizaciones" using gin (
  immutable_unaccent(lower(ie)) gin_trgm_ops
) tablespace pg_default;

create index if not exists idx_fuzzy_search_val_val
on "cgoii-data-prod"."bd_valorizaciones" using gin (
  immutable_unaccent(lower(val)) gin_trgm_ops
) tablespace pg_default;

create index if not exists idx_fuzzy_search_mes_val
on "cgoii-data-prod"."bd_valorizaciones" using gin (
  immutable_unaccent(lower(immutable_timestamp_to_text(mes))) gin_trgm_ops
) tablespace pg_default;

create index if not exists idx_fuzzy_search_grupo_servicio_val
on "cgoii-data-prod"."bd_valorizaciones" using gin (
  immutable_unaccent(lower(grupo_servicio)) gin_trgm_ops
) tablespace pg_default;
```

> **Criterio de selección de índices fuzzy:** Todas las columnas que se buscan con `ILIKE` en la función RPC, tanto las de búsqueda por defecto (`proveedor`, `ruc`, `os`, `documento_factura`, `nombre_descripcion`) como las de búsqueda con prefijo (`ie`, `val`, `mes`, `grupo_servicio`). Total: **9 índices fuzzy**.

---

### Paso 5 — Trigger para actualizar vector de búsqueda

```sql
create or replace function "cgoii-data-prod".fn_actualizar_busqueda_val()
returns trigger as $$
begin
  new.busqueda_vector := to_tsvector('spanish',
    public.unaccent(
      coalesce(new.proveedor, '') || ' ' ||
      coalesce(new.ruc, '') || ' ' ||
      coalesce(new.os, '') || ' ' ||
      coalesce(new.concepto, '') || ' ' ||
      coalesce(new.nombre_descripcion, '') || ' ' ||
      coalesce(new.documento_factura, '') || ' ' ||
      coalesce(new.centro_costos, '') || ' ' ||
      coalesce(new.comentarios, '') || ' ' ||
      coalesce(new.observacion_desestimado, '')
    )
  );
  return new;
end;
$$ language plpgsql;

create trigger tr_actualizar_busqueda_val
before insert or update on "cgoii-data-prod"."bd_valorizaciones"
for each row execute function "cgoii-data-prod".fn_actualizar_busqueda_val();
```

> **Campos en el vector:** `proveedor`, `ruc`, `os`, `concepto`, `nombre_descripcion`, `documento_factura`, `centro_costos`, `comentarios`, `observacion_desestimado`
> **Excluidos:** Campos numéricos/montos, fechas, campos cortos de estado (`aprobado`, `tipo`, `moneda`)

---

### Paso 6 — Función RPC de búsqueda (con prefijos inteligentes)

```sql
create or replace function public.buscar_valorizaciones_prod(termino_busqueda text)
returns setof "cgoii-data-prod"."bd_valorizaciones" as $$
declare
  terminos text[];
  termino text;
  valor text;
  i int;
  sql_where text := '';
  condicion text;
  termino_upper text;
begin
  -- Si el término es nulo o vacío, retornar los últimos 100 registros
  if termino_busqueda is null or trim(termino_busqueda) = '' then
    return query
    select *
    from "cgoii-data-prod"."bd_valorizaciones"
    order by id_registro desc
    limit 100;
    return;
  end if;

  -- Split por coma y limpiar espacios
  terminos := string_to_array(termino_busqueda, ',');

  -- Construir condiciones AND para cada término
  for i in 1 .. array_length(terminos, 1) loop
    termino := trim(terminos[i]);

    if termino = '' then
      continue;
    end if;

    termino_upper := upper(termino);

    -- ============================================================
    -- PASO A: Detectar PREFIJOS explícitos (IE, VAL, MES, GS, OS, RUC, PROV)
    -- El usuario escribe "PREFIJO valor" para filtrar columna específica
    -- ============================================================

    if termino_upper ~ '^IE\s+' then
      -- Prefijo IE → buscar en columna "ie"
      valor := trim(substring(termino from 3));
      condicion := format(
        'ie ILIKE ''%%%s%%''',
        replace(valor, '''', '''''')
      );

    elsif termino_upper ~ '^VAL\s+' then
      -- Prefijo VAL → buscar en columna "val"
      valor := trim(substring(termino from 4));
      condicion := format(
        'val ILIKE ''%%%s%%''',
        replace(valor, '''', '''''')
      );

    elsif termino_upper ~ '^MES\s+' then
      -- Prefijo MES → buscar en columna "mes" (timestamp, se castea a text)
      valor := trim(substring(termino from 4));
      condicion := format(
        'mes::text ILIKE ''%%%s%%''',
        replace(valor, '''', '''''')
      );

    elsif termino_upper ~ '^GS\s+' then
      -- Prefijo GS → buscar en columna "grupo_servicio"
      valor := trim(substring(termino from 3));
      condicion := format(
        'grupo_servicio ILIKE ''%%%s%%''',
        replace(valor, '''', '''''')
      );

    elsif termino_upper ~ '^OS\s+' then
      -- Prefijo OS → buscar SOLO en columna "os"
      valor := trim(substring(termino from 3));
      condicion := format(
        'os ILIKE ''%%%s%%''',
        replace(valor, '''', '''''')
      );

    elsif termino_upper ~ '^RUC\s+' then
      -- Prefijo RUC → buscar SOLO en columna "ruc"
      valor := trim(substring(termino from 4));
      condicion := format(
        'ruc ILIKE ''%%%s%%''',
        replace(valor, '''', '''''')
      );

    elsif termino_upper ~ '^PROV\s+' then
      -- Prefijo PROV → buscar SOLO en columna "proveedor"
      valor := trim(substring(termino from 5));
      condicion := format(
        'proveedor ILIKE ''%%%s%%''',
        replace(valor, '''', '''''')
      );

    -- ============================================================
    -- PASO B: Sin prefijo → detección automática por formato
    -- Búsqueda por defecto en: os, ruc, ie, proveedor, nombre_descripcion
    -- ============================================================

    elsif termino ~ '^\d{2}-\d{2}-\d{4}$' then
      -- PATRÓN FECHA (dd-mm-yyyy) → mes::text ILIKE
      condicion := format(
        'mes::text ILIKE ''%%%s%%''',
        replace(termino, '''', '''''')
      );

    elsif position('-' in termino) > 0 then
      -- PATRÓN SERIE-CORRELATIVO (contiene "-", no es fecha) → documento_factura ILIKE
      condicion := format(
        'documento_factura ILIKE ''%%%s%%''',
        replace(termino, '''', '''''')
      );

    elsif termino ~ '^\d+$' then
      -- NUMÉRICO PURO → os OR ruc OR ie OR id_registro
      condicion := format(
        '(os ILIKE ''%%%s%%'' OR ruc ILIKE ''%%%s%%'' OR ie ILIKE ''%%%s%%'' OR id_registro = %s::bigint)',
        replace(termino, '''', ''''''),
        replace(termino, '''', ''''''),
        replace(termino, '''', ''''''),
        replace(termino, '''', '''''')
      );

    else
      -- TEXTO LIBRE → buscar en campos por defecto con ILIKE + full-text
      condicion := format(
        '(proveedor ILIKE ''%%%s%%'' OR nombre_descripcion ILIKE ''%%%s%%'' OR busqueda_vector @@ websearch_to_tsquery(''spanish'', public.unaccent(%L)))',
        replace(termino, '''', ''''''),
        replace(termino, '''', ''''''),
        termino
      );

    end if;

    if sql_where = '' then
      sql_where := condicion;
    else
      sql_where := sql_where || ' AND ' || condicion;
    end if;
  end loop;

  if sql_where = '' then
    return;
  end if;

  return query execute format(
    'SELECT * FROM "cgoii-data-prod"."bd_valorizaciones" WHERE %s ORDER BY id_registro DESC LIMIT 100',
    sql_where
  );
end;
$$ language plpgsql;
```

> **Sistema de búsqueda con prefijos inteligentes:**
>
> #### Prefijos disponibles (búsqueda dirigida a columna específica)
>
> | Prefijo | Ejemplo de uso | Columna destino | Tipo búsqueda |
> |---------|---------------|-----------------|---------------|
> | `IE` | `IE 200005` | `ie` | ILIKE (parcial) |
> | `VAL` | `VAL 54` | `val` | ILIKE (parcial) |
> | `MES` | `MES 01-11-2025` | `mes` | ILIKE (parcial) |
> | `GS` | `GS gestión` | `grupo_servicio` | ILIKE (parcial) |
> | `OS` | `OS 131081` | `os` | ILIKE (parcial) |
> | `RUC` | `RUC 20609090350` | `ruc` | ILIKE (parcial) |
> | `PROV` | `PROV data solutions` | `proveedor` | ILIKE (parcial) |
>
> #### Sin prefijo (detección automática por formato)
>
> | Entrada | Tipo detectado | Campo / método |
> |---------|---------------|----------------|
> | `01-11-2025` | Fecha (dd-mm-yyyy) | `mes ILIKE` |
> | `E001-314` | Contiene `-` (no es fecha) → serie-correlativo | `documento_factura ILIKE` |
> | `131081` | Numérico puro | `os` ILIKE / `ruc` ILIKE / `ie` ILIKE / `id_registro` exacto |
> | `20609090350` | Numérico puro | Misma unión (funciona para RUC, OS, IE o ID) |
> | `200005` | Numérico puro | Misma unión (encuentra IE "200005" automáticamente) |
> | `laptops` | Texto libre | `proveedor` ILIKE / `nombre_descripcion` ILIKE / `busqueda_vector` full-text |
>
> #### Ejemplos de búsqueda combinada con comas (AND)
>
> | Búsqueda del usuario | Interpretación |
> |---------------------|----------------|
> | `IE 200005, VAL 54` | IE contiene "200005" **Y** VAL contiene "54" |
> | `200005, laptops` | Numérico busca en os/ruc/ie **Y** "laptops" en proveedor/descripción/full-text |
> | `IE 200005, laptops` | IE contiene "200005" **Y** "laptops" en proveedor/descripción/full-text |
> | `GS gestión, PROV data solutions` | Grupo servicio contiene "gestión" **Y** proveedor contiene "data solutions" |
> | `IE 200005, VAL 54, MES 01-11-2025, laptops` | 4 filtros combinados con AND |
> | `01-11-2025` | Detecta fecha → busca en `mes` automáticamente |
> | `20609090350` | Sin prefijo → busca en os, ruc, ie, id_registro automáticamente |
>
> **Los prefijos no distinguen mayúsculas/minúsculas:** `ie 200005`, `IE 200005`, `Ie 200005` funcionan igual.
>
> **Llamada desde la app:** `supabase.rpc('buscar_valorizaciones_prod', { termino_busqueda: '...' })`

---

### Paso 7 — Permisos

```sql
-- Los grants a nivel de schema ya existen, pero ejecutar por seguridad:
grant usage on schema "cgoii-data-prod" to postgres, anon, authenticated, service_role;

-- Grants específicos para la nueva tabla:
grant all on "cgoii-data-prod"."bd_valorizaciones" to postgres, anon, authenticated, service_role;
grant all on all sequences in schema "cgoii-data-prod" to postgres, anon, authenticated, service_role;
```

---

## Mapeo de columnas Excel → Supabase

| Columna Excel | Columna Supabase | Tipo | Notas |
|---------------|-----------------|------|-------|
| *(no existe)* | `id_registro` | `bigint identity` | PK auto-generado |
| ITEM | `item` | `text` | |
| COD_INT | `cod_int` | `text` | |
| TIPO | `tipo` | `text` | |
| IE | `ie` | `text` | |
| VAL | `val` | `text` | |
| MES | `mes` | `timestamp` | Convertir a formato timestamp |
| Fecha | `fecha` | `timestamp` | Convertir a formato timestamp |
| Centro de Costos | `centro_costos` | `text` | |
| GRUPO DE SERV. | `grupo_servicio` | `text` | |
| CONCEPTO | `concepto` | `text` | |
| OS | `os` | `text` | Orden de servicio |
| DOCUMENTO / FACTURA | `documento_factura` | `text` | Serie-correlativo |
| RUC | `ruc` | `text` | |
| PROVEEDOR | `proveedor` | `text` | |
| NOMBRE/DESCRIPCIÓN | `nombre_descripcion` | `text` | |
| PRESENTADO | `presentado` | `numeric` | |
| APROBADO (SI)/(NO)/(PARCIAL) | `aprobado` | `text` | |
| OBSERVACION (DESESTIMADO) | `observacion_desestimado` | `text` | |
| CONCEPTO 2 | `concepto_2` | `text` | |
| MONTO APROBADO ARCC | `monto_aprobado_arcc` | `numeric` | |
| DEST. APROB. | `dest_aprob_1` | `text` | |
| FECHA2 | `fecha_2` | `text` | |
| VAL_APB | `val_apb_1` | `text` | |
| DEST. APROB.2 | `dest_aprob_2` | `text` | |
| FECHA (MES) 2 | `fecha_mes_2` | `text` | |
| VAL_APB2 | `val_apb_2` | `text` | |
| DEST. APROB.3 | `dest_aprob_3` | `text` | |
| FECHA (MES) 3 | `fecha_mes_3` | `text` | |
| VAL_APB3 | `val_apb_3` | `text` | |
| DEST. APROB.4 | `dest_aprob_4` | `text` | |
| FECHA (MES) 4 | `fecha_mes_4` | `text` | |
| VAL_APB4 | `val_apb_4` | `text` | |
| SALDO POR APROBAR | `saldo_por_aprobar` | `numeric` | |
| TOTAL APROBADO | `total_aprobado` | `numeric` | |
| COMENTARIOS | `comentarios` | `text` | |
| NRO PAG | `nro_pag` | `text` | |
| Columna2 | `columna_2` | `text` | Reserva |
| Columna3 | `columna_3` | `text` | Reserva |
| Columna4 | `columna_4` | `text` | Reserva |

---

## Resumen de nombres (objetos en el schema)

| Objeto | Facturas (existente) | Valorizaciones (nueva) |
|--------|---------------------|----------------------|
| Tabla | `PQT06_Facturas_Consulta_Master` | `bd_valorizaciones` |
| PK constraint | `..._prod_pkey` | `bd_valorizaciones_prod_pkey` |
| Índice GIN full-text | `idx_busqueda_documentos_prod` | `idx_busqueda_valorizaciones_prod` |
| Índices fuzzy | `idx_fuzzy_search_*_prod` (4) | `idx_fuzzy_search_*_val` (9) |
| Función trigger | `fn_actualizar_busqueda_prod` | `fn_actualizar_busqueda_val` |
| Trigger | `tr_actualizar_busqueda_prod` | `tr_actualizar_busqueda_val` |
| Función RPC | `buscar_documentos_prod` | `buscar_valorizaciones_prod` |

---

## Checklist de configuración

- [ ] Schema `cgoii-data-prod` verificado
- [ ] Extensiones `unaccent` y `pg_trgm` activas
- [ ] Tabla `bd_valorizaciones` con 40 columnas + PK
- [ ] Índice GIN full-text sobre `busqueda_vector`
- [ ] Función `immutable_unaccent` verificada (global)
- [ ] Función `immutable_timestamp_to_text` creada (global, para índice sobre `mes`)
- [ ] 9 índices fuzzy (proveedor, ruc, os, documento_factura, nombre_descripcion, ie, val, mes, grupo_servicio)
- [ ] Trigger `tr_actualizar_busqueda_val` activo
- [ ] Función RPC `buscar_valorizaciones_prod` operativa (con prefijos IE, VAL, MES, GS, OS, RUC, PROV)
- [ ] Grants configurados
- [ ] Frontend apuntando a `buscar_valorizaciones_prod`

---

## Resumen de métodos de búsqueda por columna

| Columna | Índice trigrama (ILIKE) | Full-text (tsvector) | Cuándo se usa | Cómo se activa |
|---------|:-----------------------:|:--------------------:|---------------|----------------|
| `proveedor` | ✅ | ✅ | Búsqueda por defecto + prefijo `PROV` | Sin prefijo (texto libre) o `PROV valor` |
| `nombre_descripcion` | ✅ | ✅ | Búsqueda por defecto | Sin prefijo (texto libre) |
| `ruc` | ✅ | ✅ | Búsqueda por defecto + prefijo `RUC` | Sin prefijo (numérico) o `RUC valor` |
| `os` | ✅ | ✅ | Búsqueda por defecto + prefijo `OS` | Sin prefijo (numérico) o `OS valor` |
| `documento_factura` | ✅ | ✅ | Patrón serie-correlativo | Sin prefijo (contiene `-`) |
| `concepto` | ❌ | ✅ | Solo vía full-text | Sin prefijo (texto libre) |
| `centro_costos` | ❌ | ✅ | Solo vía full-text | Sin prefijo (texto libre) |
| `comentarios` | ❌ | ✅ | Solo vía full-text | Sin prefijo (texto libre) |
| `observacion_desestimado` | ❌ | ✅ | Solo vía full-text | Sin prefijo (texto libre) |
| `ie` | ✅ | ❌ | Búsqueda por defecto (numérico) + prefijo `IE` | Sin prefijo (numérico) o `IE valor` |
| `val` | ✅ | ❌ | Solo con prefijo | `VAL valor` |
| `mes` | ✅ | ❌ | Detección automática de fecha + prefijo `MES` | Sin prefijo (dd-mm-yyyy) o `MES valor` |
| `grupo_servicio` | ✅ | ❌ | Solo con prefijo | `GS valor` |

> **Leyenda:**
> - **Índice trigrama (ILIKE):** Permite búsqueda parcial. Ej: "comput" encuentra "COMPUTERS & TECNOLOGY". Ideal para fragmentos y abreviaciones.
> - **Full-text (tsvector):** Búsqueda lingüística inteligente con stemming en español. Ej: "servicio" encuentra "servicios". Ideal para palabras completas y conceptos.
> - Las columnas que tienen **ambos métodos** ofrecen la mayor cobertura: si uno no encuentra el resultado, el otro puede hacerlo.
> - Las columnas de prefijo (`val`, `grupo_servicio`) no están en el tsvector porque son campos cortos/codificados que se buscan mejor con ILIKE directo y solo con prefijo.
> - La columna `ie` no está en el tsvector pero se alcanza automáticamente cuando el usuario escribe un número sin prefijo (se busca junto con os, ruc, id_registro).
> - La columna `mes` no está en el tsvector pero se alcanza automáticamente cuando el usuario escribe una fecha en formato dd-mm-yyyy sin prefijo.
> - Las columnas solo en tsvector (`concepto`, `centro_costos`, `comentarios`, `observacion_desestimado`) no tienen índice trigrama porque no se buscan directamente con ILIKE en la función RPC — se alcanzan a través del full-text.

---

## Notas adicionales

- El campo `id_registro` se genera automáticamente. No necesita incluirse en la carga de datos desde Excel.
- Los campos de fecha: `fecha` y `mes` son `timestamp`. Los campos `fecha_2`, `fecha_mes_2`, `fecha_mes_3`, `fecha_mes_4` se mantienen como `text` tal como vienen del Excel.
- El campo `mes` es `timestamp` pero se busca casteando a texto (`mes::text ILIKE`), así el usuario puede buscar con `MES 2025-11` o `01-11-2025` y coincide con el formato almacenado por PostgreSQL.
- Los campos `DEST. APROB.` (1 a 4) y sus correspondientes `VAL_APB` y `FECHA (MES)` siguen un patrón repetitivo. Si a futuro se necesitan más de 4 aprobaciones, considerar normalizar en una tabla hija.
- Las columnas auxiliares (`columna_2`, `columna_3`, `columna_4`) se pueden eliminar si se confirma que no son necesarias.
