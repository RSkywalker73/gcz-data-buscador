# Configuración de Supabase — GCZ Data Buscador (Producción)

> **Proyecto:** GCZ Data Buscador — Producción
> **Base de datos:** PostgreSQL (Supabase) — mismo proyecto que testeo
> **Schema:** `cgoii-data-prod`
> **Última actualización:** Febrero 2026

⚠️ **Este schema convive con `cgoii-data` (testeo) en el mismo proyecto Supabase.**
Todos los objetos (funciones, triggers, índices) llevan sufijo `_prod` para evitar colisiones.

---

## Estado de implementación

| Paso | Descripción | Estado |
|------|-------------|--------|
| 1 | Crear schema `cgoii-data-prod` | ✅ Listo |
| 2 | Activar extensiones | ✅ Listo |
| 3 | Crear tabla principal | ✅ Listo |
| 4 | Crear índices de búsqueda | ✅ Listo |
| 5 | Crear trigger de búsqueda | ✅ Listo |
| 6 | Crear función RPC de búsqueda | ✅ Listo |
| 7 | Configurar permisos (RLS / Grants) | ✅ Listo |
| 8 | Frontend apuntando a producción | ✅ Listo |

---

## Guía paso a paso (replicable)

### Paso 1 — Crear schema

```sql
create schema if not exists "cgoii-data-prod";
```

---

### Paso 2 — Activar extensiones

```sql
-- Idempotente — si ya existen no hace nada
create extension if not exists unaccent schema public;
create extension if not exists pg_trgm schema public;
```

> **Nota:** Las extensiones son a nivel de base de datos, no de schema. Si ya las activaste en otro schema, este paso es seguro.

---

### Paso 3 — Crear tabla principal

```sql
create table "cgoii-data-prod"."PQT06_Facturas_Consulta_Master" (
  -- Identificador
  id_registro bigint generated by default as identity not null,

  -- Campos de control
  ctl_estado text null,
  ctl_campos_actualizados text null,
  ctl_fecha_evento timestamp without time zone null,

  -- Datos principales
  empresa text null,
  estado text null,
  id_estado integer null,
  metodo text null,
  recepcion timestamp without time zone null,
  fecha_registro timestamp without time zone null,
  fecha_comp timestamp without time zone null,
  fecha_venc timestamp without time zone null,
  forma_pago text null,
  dias_pendientes integer null,
  periodo text null,

  -- Documento y entidades
  documento_identidad text null,
  proveedor text null,
  proyecto text null,
  oc text null,
  cod_oc text null,
  unidad_negocio text null,
  id_proveedor text null,
  tipo_documento text null,
  estado_sunat text null,

  -- Detalles del comprobante
  prefijo text null,
  serie text null,
  numero_correlativo text null,
  moneda text null,

  -- Montos originales
  total_original numeric null,
  pagado_original numeric null,
  financiado_original numeric null,
  letras_original numeric null,
  fondo_garantia numeric null,
  carta_fianza numeric null,
  otras_retenciones numeric null,
  total_financiado_5 numeric null,
  deducciones numeric null,
  pendiente_comp numeric null,
  pendiente_deduccion numeric null,
  pendiente_letras numeric null,
  pend_total_soles_origen numeric null,
  pend_total_dolares numeric null,

  -- Montos en soles
  soles_total numeric null,
  soles_pagado numeric null,
  soles_financiado numeric null,
  soles_letras numeric null,
  soles_fondo_garantia numeric null,
  soles_carta_fianza numeric null,
  soles_otras_retenciones numeric null,
  soles_total_financiado_5 numeric null,
  soles_deducciones numeric null,
  soles_pendiente_comp numeric null,
  soles_pendiente_deduccion numeric null,
  soles_pendiente_letras numeric null,
  soles_pend_total_final numeric null,

  -- Percepciones y contabilidad
  percepcion numeric null,
  metodo_percepcion text null,
  perc_emitida numeric null,
  periodo_1 text null,
  correlativo_contable text null,
  suma_percepcion numeric null,
  fecha_pago_real timestamp without time zone null,
  id_tc_cancelacion text null,
  cuenta_cancelacion text null,
  corr_cancelacion text null,
  cuenta_contable text null,
  descripcion_cuenta text null,
  rubro text null,
  cod_prov text null,
  id_moneda integer null,
  tipo_cambio numeric null,
  total_local numeric null,
  total_extranjero numeric null,
  id_contable text null,
  usuario_registro text null,
  observaciones text null,
  empleado_rendir text null,
  id_empresa integer null,
  sigla_moneda text null,
  nemonico text null,
  cant_anexos integer null,
  ind_validez_cpe integer null,
  id_estado_sunat integer null,

  -- Documentos relacionados
  fecha_doc_rel timestamp without time zone null,
  tipo_doc_rel text null,
  serie_doc_rel text null,
  nro_doc_rel text null,
  concatenar_factura text null,

  -- Otros campos
  fd_oc_almacen text null,
  fd_etapa_n2_cod text null,
  fd_oc_comprador text null,
  fd_etapa_n2 text null,
  as_comentarios_procura text null,
  as_fee_no_valorizable text null,
  as_bd_val_presentacion timestamp without time zone null,
  pqt_colegio text null,

  -- Columna de búsqueda full-text
  busqueda_vector tsvector null,

  -- Primary key
  constraint PQT06_Facturas_Consulta_Master_prod_pkey primary key (id_registro)
) tablespace pg_default;
```

> 93 columnas + PK. Constraint PK renombrado a `_prod_pkey` para no colisionar con testeo.

---

### Paso 4 — Crear índices de búsqueda

#### 4a. Índice GIN para búsqueda full-text

```sql
create index if not exists idx_busqueda_documentos_prod
on "cgoii-data-prod"."PQT06_Facturas_Consulta_Master" using gin (busqueda_vector)
tablespace pg_default;
```

#### 4b. Función auxiliar `immutable_unaccent`

> PostgreSQL requiere funciones `IMMUTABLE` para crear índices sobre expresiones. `unaccent()` es `STABLE`, así que necesitamos este wrapper. Si ya existe por otro schema, `create or replace` simplemente la redefine.

```sql
create or replace function public.immutable_unaccent(text)
returns text as $$
  select public.unaccent($1);
$$ language sql immutable parallel safe;
```

#### 4c. Índices fuzzy (trigramas) para columnas con ILIKE

```sql
create index if not exists idx_fuzzy_search_proveedor_prod
on "cgoii-data-prod"."PQT06_Facturas_Consulta_Master" using gin (
  immutable_unaccent(lower(proveedor)) gin_trgm_ops
) tablespace pg_default;

create index if not exists idx_fuzzy_search_oc_prod
on "cgoii-data-prod"."PQT06_Facturas_Consulta_Master" using gin (
  immutable_unaccent(lower(oc)) gin_trgm_ops
) tablespace pg_default;

create index if not exists idx_fuzzy_search_documento_identidad_prod
on "cgoii-data-prod"."PQT06_Facturas_Consulta_Master" using gin (
  immutable_unaccent(lower(documento_identidad)) gin_trgm_ops
) tablespace pg_default;

create index if not exists idx_fuzzy_search_concatenar_factura_prod
on "cgoii-data-prod"."PQT06_Facturas_Consulta_Master" using gin (
  immutable_unaccent(lower(concatenar_factura)) gin_trgm_ops
) tablespace pg_default;
```

> **Criterio de selección de índices fuzzy:** Solo columnas que se buscan con `ILIKE` en la función RPC. Columnas buscadas solo con full-text (`tsvector`) no necesitan trigram.

---

### Paso 5 — Trigger para actualizar vector de búsqueda

```sql
create or replace function "cgoii-data-prod".fn_actualizar_busqueda_prod()
returns trigger as $$
begin
  new.busqueda_vector := to_tsvector('spanish',
    public.unaccent(
      coalesce(new.proveedor, '') || ' ' ||
      coalesce(new.documento_identidad, '') || ' ' ||
      coalesce(new.oc, '') || ' ' ||
      coalesce(new.observaciones, '') || ' ' ||
      coalesce(new.concatenar_factura, '') || ' ' ||
      coalesce(new.fd_oc_almacen, '') || ' ' ||
      coalesce(new.fd_etapa_n2, '')
    )
  );
  return new;
end;
$$ language plpgsql;

create trigger tr_actualizar_busqueda_prod
before insert or update on "cgoii-data-prod"."PQT06_Facturas_Consulta_Master"
for each row execute function "cgoii-data-prod".fn_actualizar_busqueda_prod();
```

> **Campos en el vector:** `proveedor`, `documento_identidad`, `oc`, `observaciones`, `concatenar_factura`, `fd_oc_almacen`, `fd_etapa_n2`
> **Excluidos:** `empresa` (valor único), `id_registro` (numérico, búsqueda exacta), `moneda` (muy corto, falsos positivos)

---

### Paso 6 — Función RPC de búsqueda

```sql
create or replace function public.buscar_documentos_prod(termino_busqueda text)
returns setof "cgoii-data-prod"."PQT06_Facturas_Consulta_Master" as $$
declare
  terminos text[];
  termino text;
  i int;
  sql_where text := '';
  condicion text;
begin
  -- Si el término es nulo o vacío, retornar los últimos 100 registros
  if termino_busqueda is null or trim(termino_busqueda) = '' then
    return query
    select *
    from "cgoii-data-prod"."PQT06_Facturas_Consulta_Master"
    order by id_registro desc
    limit 100;
    return;
  end if;

  -- Split por coma y limpiar espacios
  terminos := string_to_array(termino_busqueda, ',');

  -- Construir condiciones AND para cada término
  for i in 1 .. array_length(terminos, 1) loop
    termino := trim(terminos[i]);

    if termino = '' then
      continue;
    end if;

    -- Detectar tipo de término y construir condición
    if position('-' in termino) > 0 then
      -- PATRÓN SERIE-CORRELATIVO (contiene "-") → concatenar_factura ILIKE
      condicion := format(
        'concatenar_factura ILIKE ''%%%s%%''',
        replace(termino, '''', '''''')
      );

    elsif termino ~ '^\d+$' then
      -- NUMÉRICO PURO → oc OR documento_identidad OR id_registro
      condicion := format(
        '(oc ILIKE ''%%%s%%'' OR documento_identidad ILIKE ''%%%s%%'' OR id_registro = %s::bigint)',
        replace(termino, '''', ''''''),
        replace(termino, '''', ''''''),
        replace(termino, '''', ''''''')
      );

    else
      -- TEXTO LIBRE → búsqueda full-text con tsvector
      condicion := format(
        'busqueda_vector @@ websearch_to_tsquery(''spanish'', public.unaccent(%L))',
        termino
      );

    end if;

    if sql_where = '' then
      sql_where := condicion;
    else
      sql_where := sql_where || ' AND ' || condicion;
    end if;
  end loop;

  if sql_where = '' then
    return;
  end if;

  return query execute format(
    'SELECT * FROM "cgoii-data-prod"."PQT06_Facturas_Consulta_Master" WHERE %s ORDER BY id_registro DESC LIMIT 100',
    sql_where
  );
end;
$$ language plpgsql;
```

> **Lógica de detección automática de tipo:**
>
> | Entrada | Tipo detectado | Campo / método |
> |---------|---------------|----------------|
> | `E001-4000` | Contiene `-` → serie-correlativo | `concatenar_factura ILIKE` |
> | `131389` | Numérico puro | `oc` ILIKE / `documento_identidad` ILIKE / `id_registro` exacto |
> | `20601186676` | Numérico puro | Misma unión (funciona para RUC, OC o ID) |
> | `laptops` | Texto libre | `busqueda_vector` full-text |
>
> **Búsqueda con comas:** Términos separados por coma se combinan con **AND**.
> **Llamada desde la app:** `supabase.rpc('buscar_documentos_prod', { termino_busqueda: '...' })`

---

### Paso 7 — Permisos

```sql
grant usage on schema "cgoii-data-prod" to postgres, anon, authenticated, service_role;
grant all on all tables in schema "cgoii-data-prod" to postgres, anon, authenticated, service_role;
grant all on all sequences in schema "cgoii-data-prod" to postgres, anon, authenticated, service_role;
```

---

## Resumen de nombres (testeo vs producción)

| Objeto | Testeo (`cgoii-data`) | Producción (`cgoii-data-prod`) |
|--------|----------------------|-------------------------------|
| Schema | `cgoii-data` | `cgoii-data-prod` |
| Tabla | `PQT06_Facturas_Consulta_Master` | `PQT06_Facturas_Consulta_Master` |
| PK constraint | `..._pkey` | `..._prod_pkey` |
| Índice GIN full-text | `idx_busqueda_documentos` | `idx_busqueda_documentos_prod` |
| Índices fuzzy | `idx_fuzzy_search_proveedor` | `idx_fuzzy_search_*_prod` (4 índices) |
| Función `immutable_unaccent` | `public.immutable_unaccent` | Reutiliza la misma (global) |
| Función trigger | `fn_actualizar_busqueda` | `fn_actualizar_busqueda_prod` |
| Trigger | `tr_actualizar_busqueda` | `tr_actualizar_busqueda_prod` |
| Función RPC | `buscar_documentos` | `buscar_documentos_prod` |

---

## Recomendaciones para replicar en otro proyecto

### Convenciones de nombrado al compartir proyecto Supabase
- Usar sufijo en el nombre del schema (ej: `-prod`, `-staging`)
- Agregar sufijo `_prod` a constraints, índices, triggers y funciones
- La función `immutable_unaccent` es global (`public`) — no necesita duplicarse

### Extensiones requeridas
- `unaccent` — para normalizar acentos en búsquedas
- `pg_trgm` — para índices fuzzy con trigramas (ILIKE performante)

### Patrón de búsqueda multi-estrategia
1. **Full-text (`tsvector`)** para texto libre — usa diccionario `spanish` + `unaccent`
2. **ILIKE con trigramas** para patrones parciales (serie-correlativo, numéricos)
3. **Detección automática** del tipo de búsqueda según el formato del input
4. **Split por comas** para combinar múltiples criterios con AND
5. **Fallback en el frontend** si la función RPC falla: query directo con ILIKE

### Consideraciones de performance
- Índices GIN (`tsvector`) para full-text
- Índices GIN (`gin_trgm_ops`) solo en columnas que usan ILIKE — no en todas
- Trigger `BEFORE INSERT OR UPDATE` para mantener el vector actualizado automáticamente
- Límite de 100 resultados en la función RPC para proteger el rendimiento

### Seguridad
- Los grants están abiertos (anon, authenticated, service_role) — adecuado para apps internas
- Para apps públicas, considerar RLS (Row Level Security) con policies específicas
- Las credenciales de Supabase (URL + anon key) **no** se versionan en el código; se configuran manualmente

---

## Checklist de configuración

- [x] Schema `cgoii-data-prod` creado
- [x] Extensiones `unaccent` y `pg_trgm` activas
- [x] Tabla `PQT06_Facturas_Consulta_Master` con 93 columnas
- [x] Índice GIN full-text sobre `busqueda_vector`
- [x] Función `immutable_unaccent` (wrapper IMMUTABLE)
- [x] 4 índices fuzzy (proveedor, oc, documento_identidad, concatenar_factura)
- [x] Trigger `tr_actualizar_busqueda_prod` activo
- [x] Función RPC `buscar_documentos_prod` operativa
- [x] Grants configurados
- [x] Frontend apuntando a `buscar_documentos_prod` y schema `cgoii-data-prod`
